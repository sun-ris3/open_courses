{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { Reaction, _getGlobalState } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\";\n// Required by SSR when hydrating #3669\nvar getServerSnapshot = function () {};\nvar mobxGlobalState = _getGlobalState();\n// BC\nvar globalStateVersionIsAvailable = typeof mobxGlobalState.stateVersion !== \"undefined\";\nfunction createReaction(adm) {\n  adm.reaction = new Reaction(\"observer\".concat(adm.name), function () {\n    var _a;\n    if (!globalStateVersionIsAvailable) {\n      // BC\n      adm.stateVersion = Symbol();\n    }\n    // onStoreChange won't be avaliable until the component \"mounts\".\n    // If state changes in between initial render and mount,\n    // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n    (_a = adm.onStoreChange) === null || _a === void 0 ? void 0 : _a.call(adm);\n  });\n}\nexport function useObserver(render, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return render();\n  }\n  var admRef = React.useRef(null);\n  // Provides ability to force component update without changing state version\n  var _a = __read(React.useState(), 2),\n    forceUpdate = _a[1];\n  if (!admRef.current) {\n    // First render\n    var adm_1 = {\n      reaction: null,\n      onStoreChange: null,\n      stateVersion: Symbol(),\n      name: baseComponentName,\n      subscribe: function (onStoreChange) {\n        // Do NOT access admRef here!\n        observerFinalizationRegistry.unregister(adm_1);\n        adm_1.onStoreChange = onStoreChange;\n        if (!adm_1.reaction) {\n          // We've lost our reaction and therefore all subscriptions, occurs when:\n          // 1. Timer based finalization registry disposed reaction before component mounted.\n          // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n          // We have to recreate reaction and schedule re-render to recreate subscriptions,\n          // even if state did not change.\n          createReaction(adm_1);\n          // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n          forceUpdate(Symbol());\n        }\n        return function () {\n          var _a;\n          // Do NOT access admRef here!\n          adm_1.onStoreChange = null;\n          (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n          adm_1.reaction = null;\n        };\n      },\n      getSnapshot: function () {\n        // Do NOT access admRef here!\n        return globalStateVersionIsAvailable ? mobxGlobalState.stateVersion : adm_1.stateVersion;\n      }\n    };\n    admRef.current = adm_1;\n  }\n  var adm = admRef.current;\n  if (!adm.reaction) {\n    // First render or reaction was disposed by registry before subscribe\n    createReaction(adm);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    observerFinalizationRegistry.register(admRef, adm, adm);\n  }\n  React.useDebugValue(adm.reaction, printDebugValue);\n  useSyncExternalStore(\n  // Both of these must be stable, otherwise it would keep resubscribing every render.\n  adm.subscribe, adm.getSnapshot, getServerSnapshot);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var renderResult;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      renderResult = render();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return renderResult;\n}","map":{"version":3,"names":["Reaction","_getGlobalState","React","printDebugValue","isUsingStaticRendering","observerFinalizationRegistry","useSyncExternalStore","getServerSnapshot","mobxGlobalState","globalStateVersionIsAvailable","stateVersion","createReaction","adm","reaction","concat","name","Symbol","_a","onStoreChange","call","useObserver","render","baseComponentName","admRef","useRef","__read","useState","forceUpdate","current","adm_1","subscribe","unregister","dispose","getSnapshot","register","useDebugValue","renderResult","exception","track","e"],"sources":["/Users/rsun/Downloads/education/node_modules/mobx-react-lite/src/useObserver.ts"],"sourcesContent":["import { Reaction, _getGlobalState } from \"mobx\"\nimport React from \"react\"\nimport { printDebugValue } from \"./utils/printDebugValue\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\"\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\"\n\n// Required by SSR when hydrating #3669\nconst getServerSnapshot = () => {}\n\n// Do not store `admRef` (even as part of a closure!) on this object,\n// otherwise it will prevent GC and therefore reaction disposal via FinalizationRegistry.\ntype ObserverAdministration = {\n    reaction: Reaction | null // also serves as disposed flag\n    onStoreChange: Function | null // also serves as mounted flag\n    // BC: we will use local state version if global isn't available.\n    // It should behave as previous implementation - tearing is still present,\n    // because there is no cross component synchronization,\n    // but we can use `useSyncExternalStore` API.\n    stateVersion: any\n    name: string\n    // These don't depend on state/props, therefore we can keep them here instead of `useCallback`\n    subscribe: Parameters<typeof React.useSyncExternalStore>[0]\n    getSnapshot: Parameters<typeof React.useSyncExternalStore>[1]\n}\n\nconst mobxGlobalState = _getGlobalState()\n\n// BC\nconst globalStateVersionIsAvailable = typeof mobxGlobalState.stateVersion !== \"undefined\"\n\nfunction createReaction(adm: ObserverAdministration) {\n    adm.reaction = new Reaction(`observer${adm.name}`, () => {\n        if (!globalStateVersionIsAvailable) {\n            // BC\n            adm.stateVersion = Symbol()\n        }\n        // onStoreChange won't be avaliable until the component \"mounts\".\n        // If state changes in between initial render and mount,\n        // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n        adm.onStoreChange?.()\n    })\n}\n\nexport function useObserver<T>(render: () => T, baseComponentName: string = \"observed\"): T {\n    if (isUsingStaticRendering()) {\n        return render()\n    }\n\n    const admRef = React.useRef<ObserverAdministration | null>(null)\n\n    // Provides ability to force component update without changing state version\n    const [, forceUpdate] = React.useState<Symbol>()\n\n    if (!admRef.current) {\n        // First render\n        const adm: ObserverAdministration = {\n            reaction: null,\n            onStoreChange: null,\n            stateVersion: Symbol(),\n            name: baseComponentName,\n            subscribe(onStoreChange: () => void) {\n                // Do NOT access admRef here!\n                observerFinalizationRegistry.unregister(adm)\n                adm.onStoreChange = onStoreChange\n                if (!adm.reaction) {\n                    // We've lost our reaction and therefore all subscriptions, occurs when:\n                    // 1. Timer based finalization registry disposed reaction before component mounted.\n                    // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n                    // We have to recreate reaction and schedule re-render to recreate subscriptions,\n                    // even if state did not change.\n                    createReaction(adm)\n                    // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n                    forceUpdate(Symbol())\n                }\n\n                return () => {\n                    // Do NOT access admRef here!\n                    adm.onStoreChange = null\n                    adm.reaction?.dispose()\n                    adm.reaction = null\n                }\n            },\n            getSnapshot() {\n                // Do NOT access admRef here!\n                return globalStateVersionIsAvailable\n                    ? mobxGlobalState.stateVersion\n                    : adm.stateVersion\n            }\n        }\n\n        admRef.current = adm\n    }\n\n    const adm = admRef.current!\n\n    if (!adm.reaction) {\n        // First render or reaction was disposed by registry before subscribe\n        createReaction(adm)\n        // StrictMode/ConcurrentMode/Suspense may mean that our component is\n        // rendered and abandoned multiple times, so we need to track leaked\n        // Reactions.\n        observerFinalizationRegistry.register(admRef, adm, adm)\n    }\n\n    React.useDebugValue(adm.reaction!, printDebugValue)\n\n    useSyncExternalStore(\n        // Both of these must be stable, otherwise it would keep resubscribing every render.\n        adm.subscribe,\n        adm.getSnapshot,\n        getServerSnapshot\n    )\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let renderResult!: T\n    let exception\n    adm.reaction!.track(() => {\n        try {\n            renderResult = render()\n        } catch (e) {\n            exception = e\n        }\n    })\n\n    if (exception) {\n        throw exception // re-throw any exceptions caught during rendering\n    }\n\n    return renderResult\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}